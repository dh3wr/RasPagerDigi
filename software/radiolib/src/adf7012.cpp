#include <wiringPi.h>
#include <math.h>
#include <iostream>
#include <time.h>
#include "stdlib.h"
#include "adf7012.h"

unsigned int powerlevel;

//Registervariablen anlegen: adf_config ===========================================================

struct {
	struct {
		unsigned int  frequency_error_correction;
		unsigned char r_divider;
		unsigned char crystal_doubler;
		unsigned char crystal_oscillator_disable;
		unsigned char clock_out_divider;
		unsigned char vco_adjust;
		unsigned char output_divider;
	} r0;

	struct {
		unsigned int  fractional_n;
		unsigned char integer_n;
		unsigned char prescaler;
	} r1;

	struct {
		unsigned char mod_control;
		unsigned char gook;
		unsigned char power_amplifier_level;
		unsigned int  modulation_deviation;
		unsigned char gfsk_modulation_control;
		unsigned char index_counter;
	} r2;

	struct {
		unsigned char pll_enable;
		unsigned char pa_enable;
		unsigned char clkout_enable;
		unsigned char data_invert;
		unsigned char charge_pump_current;
		unsigned char bleed_up;
		unsigned char bleed_down;
		unsigned char vco_disable;
		unsigned char muxout;
		unsigned char ld_precision;
		unsigned char vco_bias;
		unsigned char pa_bias;
		unsigned char pll_test_mode;
		unsigned char sd_test_mode;
	} r3;
} adf_config;




// Konfiguration des ADF ==========================================================================

// Power up default settings are defined here:

void RadioAdf7012::adf_reset_register_zero(void) {
	adf_config.r0.frequency_error_correction = -40;               // Don't bother for now... -67
	adf_config.r0.r_divider = ADF7012_CRYSTAL_DIVIDER;          // Whatever works best for 2m, 1.25m and 70 cm ham bands
	adf_config.r0.crystal_doubler = 0;                          // W  ho would want that? Lower f_pfd means finer channel steps.
	adf_config.r0.crystal_oscillator_disable = 0;               // Disable internal crystal oscillator because we have an external VCXO
	adf_config.r0.clock_out_divider = 1;                        // Don't bother for now...
	adf_config.r0.vco_adjust = 2;                               // Don't bother for now... (Will be automatically adjusted until PLL lock is achieved)
	adf_config.r0.output_divider = ADF_OUTPUT_DIVIDER_BY_2;     // Pre-set div 4 for 2m. Will be changed according tx frequency on the fly
}

void RadioAdf7012::adf_reset_register_one(void) {
	adf_config.r1.integer_n = 179;                              // Pre-set for 144.390 MHz APRS. Will be changed according tx frequency on the fly
	adf_config.r1.fractional_n = 128;                          // Pre-set for 144.390 MHz APRS. Will be changed according tx frequency on the fly
	adf_config.r1.prescaler = ADF_PRESCALER_4_5;                // 8/9 requires an integer_n > 91; 4/5 only requires integer_n > 31
}

void RadioAdf7012::adf_reset_register_two(void) {
	adf_config.r2.mod_control = ADF_MODULATION_FSK;             // For AFSK the modulation is done through the external VCXO we don't want any FM generated by the ADF7012 itself
	adf_config.r2.gook = 0;                                     // Whatever... This might give us a nicer swing in phase maybe...
	adf_config.r2.power_amplifier_level = 30;                   // 16 is about half maximum power. Output −20dBm at 0x0, and 13 dBm at 0x7E at 868 MHz
	adf_config.r2.modulation_deviation = 13;                    // 16 is about half maximum amplitude @ ASK.
	adf_config.r2.gfsk_modulation_control = 0;                  // Don't bother for now...
	adf_config.r2.index_counter = 0;                            // Don't bother for now...
}

void RadioAdf7012::adf_reset_register_three(void) {
	adf_config.r3.pll_enable = 0;                               // Switch off PLL (will be switched on after Ureg is checked and confirmed ok)
	adf_config.r3.pa_enable = 0;                                // Switch off PA  (will be switched on when PLL lock is confirmed)
	adf_config.r3.clkout_enable = 0;                            // No clock output needed at the moment
	adf_config.r3.data_invert = 1;                              // Results in a TX signal when TXDATA input is low
	adf_config.r3.charge_pump_current = ADF_CP_CURRENT_2_1;     // 2.1 mA. This is the maximum
	adf_config.r3.bleed_up = 0;                                 // Don't worry, be happy...
	adf_config.r3.bleed_down = 0;                               // Dito
	adf_config.r3.vco_disable = 0;                              // VCO is on
	adf_config.r3.muxout = ADF_MUXOUT_REG_READY;                // Lights up the green LED if the ADF7012 is properly powered (changes to lock detection in a later stage)
	adf_config.r3.ld_precision = ADF_LD_PRECISION_3_CYCLES;     // What the heck? It is recommended that LDP be set to 1; 0 is more relaxed
	adf_config.r3.vco_bias = 1;                                 // In 0.5 mA steps; Default 6 means 3 mA; Maximum (15) is 8 mA
	adf_config.r3.pa_bias = 4;                                  // In 1 mA steps; Default 4 means 8 mA; Minimum (0) is 5 mA; Maximum (7) is 12 mA (Datasheet says uA which is bullshit)
	adf_config.r3.pll_test_mode = 0;
	adf_config.r3.sd_test_mode = 0;
}




// Resetfunktion ----------------------------------------------------------------------------------
void RadioAdf7012::adf_reset_config(void)
{
	adf_reset_register_zero();
	adf_reset_register_one();
	adf_reset_register_two();
	adf_reset_register_three();
	//    adf_reset();  
	//    while(!adf_reg_ready());
}




// Configuration writing functions ----------------------------------------------------------------
void RadioAdf7012::adf_write_config(void)
{
	adf_write_register_zero();
	adf_write_register_one();
	adf_write_register_two();
	adf_write_register_three();
}


void RadioAdf7012::adf_write_register_zero(void)
{
	unsigned long reg =
		(0) |
		((unsigned long)(adf_config.r0.frequency_error_correction & 0x7FF) << 2U) |
		((unsigned long)(adf_config.r0.r_divider & 0xF) << 13U) |
		((unsigned long)(adf_config.r0.crystal_doubler & 0x1) << 17U) |
		((unsigned long)(adf_config.r0.crystal_oscillator_disable & 0x1) << 18U) |
		((unsigned long)(adf_config.r0.clock_out_divider & 0xF) << 19U) |
		((unsigned long)(adf_config.r0.vco_adjust & 0x3) << 23U) |
		((unsigned long)(adf_config.r0.output_divider & 0x3) << 25U);

	adf_write_register(reg);
}


void RadioAdf7012::adf_write_register_one(void)
{
	unsigned long reg =
		(1) |
		((unsigned long)(adf_config.r1.fractional_n & 0xFFF) << 2) |
		((unsigned long)(adf_config.r1.integer_n & 0xFF) << 14) |
		((unsigned long)(adf_config.r1.prescaler & 0x1) << 22);

	adf_write_register(reg);
}


void RadioAdf7012::adf_write_register_two(void)
{
	unsigned long reg =
		(2) |
		((unsigned long)(adf_config.r2.mod_control & 0x3) << 2) |
		((unsigned long)(adf_config.r2.gook & 0x1) << 4) |
		((unsigned long)(adf_config.r2.power_amplifier_level & 0x3F) << 5) |
		((unsigned long)(adf_config.r2.modulation_deviation & 0x1FF) << 11) |
		((unsigned long)(adf_config.r2.gfsk_modulation_control & 0x7) << 20) |
		((unsigned long)(adf_config.r2.index_counter & 0x3) << 23);

	adf_write_register(reg);
}


void RadioAdf7012::adf_write_register_three(void)
{
	unsigned long reg =
		(3) |
		((unsigned long)(adf_config.r3.pll_enable & 0x1) << 2) |
		((unsigned long)(adf_config.r3.pa_enable & 0x1) << 3) |
		((unsigned long)(adf_config.r3.clkout_enable & 0x1) << 4) |
		((unsigned long)(adf_config.r3.data_invert & 0x1) << 5) |
		((unsigned long)(adf_config.r3.charge_pump_current & 0x3) << 6) |
		((unsigned long)(adf_config.r3.bleed_up & 0x1) << 8) |
		((unsigned long)(adf_config.r3.bleed_down & 0x1) << 9) |
		((unsigned long)(adf_config.r3.vco_disable & 0x1) << 10) |
		((unsigned long)(adf_config.r3.muxout & 0xF) << 11) |
		((unsigned long)(adf_config.r3.ld_precision & 0x1) << 15) |
		((unsigned long)(adf_config.r3.vco_bias & 0xF) << 16) |
		((unsigned long)(adf_config.r3.pa_bias & 0x7) << 20) |
		((unsigned long)(adf_config.r3.pll_test_mode & 0x1F) << 23) |
		((unsigned long)(adf_config.r3.sd_test_mode & 0xF) << 28);

	adf_write_register(reg);
}




void RadioAdf7012::adf_write_register(unsigned long data)
{
	int i;
	digitalWrite(CLK, LOW);
	delayMicroseconds(2);
	digitalWrite(LE, LOW);
	delayMicroseconds(10);

	for (i = 31; i >= 0; i--) {
		if ((data & (unsigned long)(1UL << i)) >> i)
			digitalWrite(SDATA, HIGH);
		else
			digitalWrite(SDATA, LOW);
		delayMicroseconds(10);
		digitalWrite(CLK, HIGH);
		delayMicroseconds(30);
		digitalWrite(CLK, LOW);
		delayMicroseconds(30);
	}
	delayMicroseconds(10);
	digitalWrite(LE, HIGH);
}




void RadioAdf7012::adf_reset(void)
{
	digitalWrite(CE, LOW);
	digitalWrite(LE, HIGH);
	digitalWrite(TXDATA, HIGH);
	digitalWrite(CLK, HIGH);
	digitalWrite(SDATA, HIGH);

	delay(5);

	digitalWrite(CE, HIGH);

	delay(100);
}




// Steuerungsfunktionen ===========================================================================

bool RadioAdf7012::ptt_on()
{
	digitalWrite(CE, HIGH);
	digitalWrite(TXDATA, LOW);
	adf_config.r3.pa_enable = 0;
	adf_config.r2.power_amplifier_level = 0;
	adf_config.r3.muxout = ADF_MUXOUT_REG_READY;

	adf_write_config();
	delay(100);

	int adc = digitalRead(MUXOUT);


	if (adc != 0U)           // Power is good apparently
	{
		if (adf_lock())
		{
			adf_config.r3.pa_enable = 1;
			adf_config.r2.power_amplifier_level = 63; //63 is max power
			adf_write_config();
			delay(50);
			return true;
		}
		else
		{
			ptt_off();
		}
	}
	return false;
}




void RadioAdf7012::ptt_off()
{
	adf_config.r3.pa_enable = 0;
	adf_config.r2.power_amplifier_level = 0;
	adf_write_config();
	delay(100);

	digitalWrite(CE, LOW);
	digitalWrite(TXDATA, LOW);
}




int RadioAdf7012::adf_lock(void)
{
	int adj = adf_config.r0.vco_adjust; // use default start values from setup
	int bias = adf_config.r3.vco_bias;  // or the updated ones that worked last time

	adf_config.r3.pll_enable = 1;
	adf_config.r3.muxout = ADF_MUXOUT_DIGITAL_LOCK;
	
	adf_write_config();
	delay(500);

	while (!adf_locked()) {
		adf_config.r0.vco_adjust = adj; 
		adf_config.r3.vco_bias = bias;
		adf_config.r3.muxout = ADF_MUXOUT_DIGITAL_LOCK;
		adf_write_config();
		delay(500);
		if (++bias == 14) {
			bias = 1;
			if (++adj == 4) {

				adf_config.r0.vco_adjust = 0;
				adf_config.r3.vco_bias = 0;
				return 0;
			}
		}
		
	}
	
	return 1;
}




int RadioAdf7012::adf_locked(void)
{
	//delay(500);
	int adc = digitalRead(MUXOUT);
	//std::cout << adc <<" " << (int)adf_config.r0.vco_adjust << " " << (int)adf_config.r3.vco_bias<< std::endl;
	//delay(500);
	if (adc == 1)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}




int RadioAdf7012::get_powerlevel()
{
	return powerlevel;
}



// hier wird die Frequenz gesetzt und auch die Werte für die PLL berechnet ------------------------

void RadioAdf7012::set_freq(unsigned long freq)
{
	adf_config.r0.output_divider = ADF_OUTPUT_DIVIDER_BY_1;
//	if (freq < 450000000) { adf_config.r0.output_divider = ADF_OUTPUT_DIVIDER_BY_2; };
//	if (freq < 210000000) { adf_config.r0.output_divider = ADF_OUTPUT_DIVIDER_BY_4; };
//	if (freq < 130000000) { adf_config.r0.output_divider = ADF_OUTPUT_DIVIDER_BY_8; };
	unsigned long f_pfd = CRYSTALFREQ / adf_config.r0.r_divider;

	unsigned int n = (unsigned int)(freq / f_pfd);

	float ratio = (float)freq / (float)f_pfd;
	float rest = ratio - (float)n;

	unsigned long m = (unsigned long)(rest * 4096);

	
	//std::cout << m << std::endl;
	//std::cout << n << std::endl;
	
	adf_config.r1.integer_n =  n;				//bösartigerweise mal die Werte reingeschrieben, die in ADF_sim herauskommen, nicht die berechneten!
	adf_config.r1.fractional_n = m;
}




void RadioAdf7012::setup()
{
	/*std::cout << "==============================================================" << std::endl;
	std::cout << "ADF7012 setup start" << std::endl;
	std::cout << "==============================================================" << std::endl;*/

	pinMode(CE, OUTPUT);
	pinMode(CLK, OUTPUT);
	pinMode(LE, OUTPUT);
	pinMode(SDATA, OUTPUT);
	pinMode(TXDATA, OUTPUT);

	adf_reset_config();
	set_freq(FREQUENCY); // Set the default frequency
	adf_write_config();
	
	digitalWrite(TXDATA, LOW);
	//  digitalWrite(TX_PA_PIN, HIGH);  // HIGH = off => make sure the PA is off after boot.
	delay(100);
}